<html>
<H2  ALIGN=CENTER><FONT COLOR="#DC143C">sc_rate.pl.html</H2></FONT>
<br>
<H6 ALIGN=RIGHT>Sun Oct 12 07:00:39 BST 1997
Created by  <A href="/gn0/jong/Perl/headbox2html.pl.html">/gn0/jong/Perl/headbox2html.pl</A></H6> <hr><H3><A href="sc_rate.pl.html">sc_rate</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/sc_rate.pl">sc_rate.pl</A>
<pre>
<b>Argument  </b> : Upto 2 files and various options (in '-h'  or 'h' format )
<b>Author    </b> : A Biomatic
<b>Class     </b> : Bio
<b>Example   </b> : sc_rate.pl aa.msf aa.jp
<b>Function  </b> : Evaluates the quality of any sequence alignment.
             This caculates, basically, the Sequence identity(in %) divided
             by Composition identity rate of sequences with certain scanning
             window size of (8 ~ 24)
<b>Keywords  </b> : SC rate, Sequence identity, composition identity
<b>Options   </b> : Following vars are read into the program at initialization by &parse_arguments
             subroutine, so please leave them. It is not just comments.
    $av_sc_segment     becomes    1  by  a  # To smooth the SC rates
                                  SC rates with Window size defined by a=X  .
    $make_gap_dot      becomes    d  by  d  # Modifies SC rate by a dynamic factor of window
    $av_sc_segment           =   [ ] by  a= # window size for averaging after getting SC rates
    $show_calculation  becomes    s  by  s  # Shows the scanning windows during calculation
    $no_stat           becomes    ns by  ns # do not show stat with 2 file inputs(
    $variable_win_size becomes    v  by  v  # This sets the scan win size dynamic
    $output_ordered    becomes    o  by  o  # in final printing, seq
    $interlaced_out    becomes    i  by  i  # in final printing, seq
    $normal_sc_rate    becomes    n  by  n  # Normalize (0-9) the SC rates
    $normal_er_rate    becomes    e  by  e  # Normalize (0-9) the error rates(2 file input)
    $conv_err_2_bin    becomes    c  by  c  # Converts error rates to 0 or 1 (occurred or not)
    $redu_window       becomes    r  by  r  # Tries to reduce the scan wind
                                            This is only activated with 'v' option.
    $apply_factor      becomes    f  by  f  # Modifies SC rate by a dynamic factor of window
                                            size. This is only activated with 'v' option
    $minus_whole_cs    becomes    m  by  m  # substracts rates with whole seq
                                            # this makes rates more strict in predicting
    $print_width_size  is        [ ] by  w= # the final output print block width

    $ss_opt            becomes    ss by  ss, SS, -ss, -SS     #  for secondary structure only
    $H                 =         'H' by   -H or -h or H or h  # to retrieve only H segment
    $S                 becomes   'S' by   -S or  S            # to retrieve only S segment
    $E                 becomes   'E' by   -E or  E            # to retrieve only E segment
    $T                 becomes   'T' by   -T or -t or T or t  # to retrieve only T segment
    $I                 becomes   'I' by   -I or  I            # to retrieve only I segment
    $G                 becomes   'G' by   -G or -g or G or g  # to retrieve only G segment
    $B                 becomes   'B' by   -B or -b or B or b  # to retrieve only B segment
    $HELP              becomes    1  by   -help   # for showing help
    $simplify          becomes    1  by   -p or P or -P, p
    $simplify          becomes    1  by   -simplify or simplify, Simplify SIMPLIFY
    $comm_col          becomes   'C' by   -C or C or common
    $LIMIT             becomes    L  by   -L, L               # to limit the error rate to 9 .
    $HELP              becomes    1  by   -h, h, '?'          # for showing help
<b>Returns   </b> : No file writing.
<b>Tips      </b> : This is handy to see how reliable your alignment is.
<b>Usage     </b> : sc_rate.pl test_file.msf [test_structure_file.jp]
<b>Used in   </b> : Bio
<b>Version   </b> : 1.1
<b>Warning   </b> : Takes 'ALIGNED' sequences. So, need at least a pair of seqs aligned.
</pre><hr>

<H3><A href="scan_win_and_get_sc_rate_pairs
.pl.html">scan_win_and_get_sc_rate_pairs
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/scan_win_and_get_sc_rate_pairs
.pl">scan_win_and_get_sc_rate_pairs
.pl</A>
<pre>
<b>Argument  </b> : One ref. for hash, one ref. for a scalar.
<b>Example   </b> : input hash: ( seq1,  'ABCDEFG.HIK',      (2 or more sequences accepted)
                         seq2,  'DFD..ASDFAFS',
                         seq3,  'DDDDD..ASDFAFS' );
             input winsize : 5;

             output hash; (seq1seq2, 1,2,2,2,1,1,2,2); <-- joined by ',';
             output hash; (seq1seq3, 1,2,2,2,1,1,2,2); <-- joined by ',';
                  The numbers are ratios(compos/seqid) with given window size.
<b>Function  </b> : scans input sequences(arg1) in a given(arg2) window size and gets
             each composition and sequence identity rate(sc_rate) of the window.
             sc rate = Sequence Id(%)/ Composition Id(%)
<b>Returns   </b> : a reference of a hash.
<b>Usage     </b> : %out1 = %{&scan_win_and_get_sc_rate_pairs(\%input, \$window_size)};
<b>Version   </b> : 1.0
<b>Warning   </b> : when $seqid is zero  the rate becomes $compos_id/10   !!!
</pre><hr>

<H3><A href="get_windows_sc_rate_array
.pl.html">get_windows_sc_rate_array
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_windows_sc_rate_array
.pl">get_windows_sc_rate_array
.pl</A>
<pre>
<b>Argument  </b> : (\@input, \$window_size);  @input => ('ABCDEFG.HIK', 'DFD..ASDFAFS', 'ASDFASDFASAS');
             Input ar => ( 'ABCDEFG
                'DFD..ASDFAFS'
                'ASDFASDFASAS' )  as the name of  @sequences.
<b>Author    </b> : A Biomatic
<b>Function  </b> : actual working part of scan_windows_and_get_compos_seqid_rate
<b>Returns   </b> : \@ratio_array, \$ratio_whole_seq
<b>Usage     </b> : @out_rate = @{&get_windows_compos_and_seqid_rate_array(\@seq, \$win_size)};
</pre><hr>

<H3><A href="get_segment_shift_rate
.pl.html">get_segment_shift_rate
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_segment_shift_rate
.pl">get_segment_shift_rate
.pl</A>
<pre>
<b>Argument  </b> : Two references of hashes. One for error rate the other for sec.
             assignment.
<b>Example   </b> : <input example> First block is for the first hash input
                             and Second is for the second hash input.

             1cdg_6taa      00000442222222222242222222222777700000007000000000
             1cdg_2aaa      00000442222222222242222222222777700000007000000000
             2aaa_6taa      00000000000000000000000000000000000000000000000000

             1cdg_6taa      -------EEE-----------EE--EEEE------EE---------EEE-
             1cdg_2aaa      -------EEE-----------EE--EEEE------EE---------EEE-
             2aaa_6taa      -------EEEEE------EE-EEEEEEEE----EEEE-------EEEEE-

             <intermediate output example>
             2aaa_6taa      -------00000---------00000000----0000-------00000-
             1cdg_6taa      -------442---------------2222-----------------000-
             1cdg_2aaa      -------222---------------2222-----------------000-

             <Final output>
             2aaa_6taa      0%
             1cdg_6taa      67%
             1cdg_2aaa      67%

<b>Function  </b> : calculates the secondary structure segment shift rate.
<b>Options   </b> : 'p' or 'P' for percentage term(default)
             'r' or 'R' for ratio term (0.0 - 1.0), where 1 means all the
              segments were wrongly aligned.
             's' or 'S' for Shift rate (it actually caculates the position shift
              rate for the secondary structure segment.
             'h' or 'H' for position Shift rate (it actually caculates the position
              shift rate for helical segments). If this is the only option, it
              will show the default percentage term rate for helical segments.
              If used with 'r', it will give you ratio (0.0 - 1.0) for helical
              segment. If used with 's' option, it will give you position shift
              rate for only helical segments.
             'e' or 'E' for position Shift rate (it actually caculates the position
              shift rate for beta segments). If this is the only option, it will
              show the default percentage term rate for beta segments. If used
              with 'r', it will give you ratio (0.0 - 1.0) for beta. If used
              with 's' option, it will give you position shift rate for only
              beta segments.
<b>Usage     </b> : &get_segment_shift_rate(\%hash_for_errors, \%hash_for_sec_str);
<b>Version   </b> : 1.1
</pre><hr>

<H3><A href="search_files_in_subdir
.pl.html">search_files_in_subdir
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/search_files_in_subdir
.pl">search_files_in_subdir
.pl</A>
<pre>
<b>Argument  </b> : gets a ref. of a scaler (dir name) and returns nothing(void).
<b>Author    </b> : A Biomatic
<b>Function  </b> : open dir and process all files in the dir if you wish,
             and then go in any other sub
             if any file(dir) is linked, it skips that file.
<b>Usage     </b> : 
                     $inputdir='/nfs/ind4/ccpe1/people/A Biomatic /jpo/align';
<b>Warning   </b> : the final var $found_from_search_files_in_subdir mustn't be 'my'ed.
</pre><hr>

<H3><A href="read_any_dir
.pl.html">read_any_dir
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/read_any_dir
.pl">read_any_dir
.pl</A>
<pre>
<b>Argument  </b> : takes one scaler reference.
<b>Author    </b> : A Biomatic
<b>Function  </b> : read any dir and REMOVES the '.' and '..' entries. And then put in array.
<b>Returns   </b> : one ref. of array.
<b>Usage     </b> : @file_list = @{&read_any_dir(\$absolute_path_dir_name)};
</pre><hr>

<H3><A href="scan_win_get_average
.pl.html">scan_win_get_average
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/scan_win_get_average
.pl">scan_win_get_average
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Example   </b> : input hash: ( seq1,  '13241234141234234',      (2 or more sequences accepted)
                         seq2,  '1341324123413241234')
             input winsize : 5;

             output hash; (seq1, 1234123413241234);
             output hash; (seq2, 1344234123412341);
                  The numbers are ratios(compos/seqid) with given window size.
<b>Usage     </b> : %out1 = %{&scan_win_get_av(\%input, \$window_size, \%input2,,,,)};
             The order of the arguments doesn't matter.
</pre><hr>

<H3><A href="tally_2_hashes
.pl.html">tally_2_hashes
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/tally_2_hashes
.pl">tally_2_hashes
.pl</A>
<pre>
<b>Argument  </b> : (\%hash1, \%hash2) or optionally (\%hash1, \%hash2, ['n', 'i', 'p', 'a'])
             'n' => normalizing, 'p' => percentage out, 'i' => make int out, 'a'=> averaged
<b>Author    </b> : A Biomatic
<b>Example   </b> : you put two hash refs. (ass. array) as args (\%hash1, \%hash2)
             The hashes are like; hash1  (name1, 0000011111, name2, 0000122222 );
                                  hash2  (name3, 1324..1341, name4, 13424444.. );

             1) The resulting 1st hash output is (0, 20,   1, 13,     2, 12)
             which means that 0 added up to 24 in the second arg hash positions
                              1 added up to 15 in the second arg hash positions
                              2 added up to 18 in the second arg hash positions
             'p' option only works with 'n' or 'a'
             2) The resulting 2nd hash output is (0, 5,   1, 5)
             which means that 0 occurred 5 times in the first input hash
                              1 occurred 5 times in the first input hash
             'p' option only works with 'n' or 'a'
<b>Function  </b> : Makes hashes of tallied occurances and summed up values for disits in
             positions.
             calculates the occurances or occurance rates of CS rate positions.
             The hashes should have numbers.
<b>Keywords  </b> : tally two hashes of numbers.
<b>Options   </b> : [a n i p]
<b>Package   </b> : Bio
<b>Returns   </b> : ($ref1, $ref2), ie, two references of hash
             averaging option causes division of 20(added up value)
                                                by 9(occurance) in the above
             for '0' of the first hash, so (0, 2.222,  1, 2.1666,  2, 2.4 )
             Average is the average of numbers
             average value in 0-9 scale (or 0-100 with 'p' option)
             So, if there are
                  seq1 00111110000,   The 'a' value of 0 and 1 as in the seq2
                  seq2 33000040000    is 0-> 6/6, 1-> 4/5, while the 'n'
                                        calc would be, 0-> 6 (60%), 1-> 4(40%)

<b>Usage     </b> : ($ref1, $ref2) = &tally_2_hashes(\%hash1, \%hash2, ['n', 'a', 'p', 'i']);
              %tally_addedup=%{$ref1};    '0' position had addedup value of 1000
              %tally_occurances=%{$ref2}; '0' position had occurred 100 times,
                                          '0' on average had 10 in its
                                              corresponding hash positions
<b>Used in   </b> : get_position_shift_rate
<b>Version   </b> : 1.2
</pre><hr>

<H3><A href="normalize_numbers
.pl.html">normalize_numbers
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/normalize_numbers
.pl">normalize_numbers
.pl</A>
<pre>
<b>Argument  </b> : (\%hash1, %hash2, ....)
<b>Author    </b> : A Biomatic
<b>Function  </b> : with given numbers in hashes, it makes a scale of 0-9 and puts
             all the elements in the scale. Also returns the average of the numbs.
<b>Returns   </b> : (\%norm_hash1, \%norm_hash2, \%norm_hash3,.... )

             Example> intputhash>                   Outputhash>
             ( '1-2', '12,.,1,2,3,4',     ( '1-2',   '9,.,0,1,2,3',
              '2-3', '12,.,1,5,3,4',       '2-3',   '9,.,0,4,2,3',
              '4-3', '12,3,1,2,3,4',       '3-1',   '9,3,.,.,2,3',
              '3-1', '12,4,.,.,3,4' );     '4-3',   '9,2,0,1,2,3' );

<b>Usage     </b> : %output=%{&normalize_numbers(\%hash1)};
             originally made to normalize the result of get_posi_rates_hash_out
             in   'scan_compos_and_seqid.pl'
</pre><hr>

<H3><A href="show_hash
.pl.html">show_hash
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/show_hash
.pl">show_hash
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : for debugging purpose. Shows any hash elems line by line in 2 columns.
<b>Usage     </b> : &show_hash(\%input_hash1, \%input_hash2,.....);
</pre><hr>

<H3><A href="print_seq_in_columns
.pl.html">print_seq_in_columns
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/print_seq_in_columns
.pl">print_seq_in_columns
.pl</A>
<pre>
<b>Argument  </b> : many refs  for hash (one for bottm, one for top, etc,top hash is usually
               to denote certain caculations or results of the bottom one
<b>Author    </b> : A Biomatic
<b>Example   </b> : With command 'print_seq_in_columns.pl c2 s2', you get:

      name1 11111111  name1 22222
      name2 11        name2 2222222
      name3 1111111   name3 22222
      name4 11111     name4 2222
      name5 11111     name5 222

      name1 3333      name1 4444
      name2 3333      name2 444
      name3 333       name3 4
      name4 333       name4 4444
      name5 3333      name5 4444444

<b>Function  </b> : gets many refs  for one scalar  or hashes and prints
               the contents in lines of \$block_leng(the only scalar ref. given) char.
<b>Options   </b> : c, i, s
<b>Usage     </b> : &print_seq_in_block (\$block_leng, 'i',\%h1, 'sort', \%h2, \%hash3,,,);
<b>Version   </b> : 1.0
</pre><hr>

<H3><A href="get_position_shift_rate
.pl.html">get_position_shift_rate
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_position_shift_rate
.pl">get_position_shift_rate
.pl</A>
<pre>
<b>Argument  </b> : %{&get_position_shift_rate(\%msfo_file, \%jpo_file)};
             Whatever the names, it takes one TRUE structral and one ALIGNED hash.
<b>Author    </b> : A Biomatic
<b>Example   </b> : my(%error_rate)=%{&get_position_shift_rate(\%input, \%input2)};
<b>Function  </b> : This is to get position specific error rate for line display rather than
             actual final error rate for the alignment. Takes two file names of seq.
             Output >>
             seq1_seq2  1110...222...2222
             seq2_seq3  1111....10...1111
             seq1_seq3  1111....0000.0000

<b>Options   </b> : 'ss' for secondary structure regions(Helix and Beta region only
                 calculation for error rate). There is specialized sub called
              get_segment_shift_rate for sec. str. only handling.

    $ss_opt            becomes    ss by  ss, SS, -ss, -SS     #  for secondary structure only
    $H                 =         'H' by   -H or -h or H       # to retrieve only H segment
    $S                 becomes   'S' by   -S or  S            # to retrieve only S segment
    $E                 becomes   'E' by   -E or  E            # to retrieve only E segment
    $T                 becomes   'T' by   -T or -t or T or t  # to retrieve only T segment
    $I                 becomes   'I' by   -I or  I            # to retrieve only I segment
    $G                 becomes   'G' by   -G or -g or G or g  # to retrieve only G segment
    $B                 becomes   'B' by   -B or -b or B or b  # to retrieve only B segment
    $HELP              becomes    1  by   -help   # for showing help
    $simplify          becomes    1  by   -p or P or -P, p
    $simplify          becomes    1  by   -simplify or simplify, Simplify SIMPLIFY
    $comm_col          becomes   'C' by   -C or C or common
    $LIMIT             becomes    L  by   -L, L               # to limit the error rate to 9 .

<b>Returns   </b> : \%final_posi_diffs;
<b>Usage     </b> : %rate_hash = %{&get_position_shift_rate(\%hash_msf, \%hash_jp)};
<b>Version   </b> : 1.5
<b>Warning   </b> : split and join char is ','; (space)
</pre><hr>

<H3><A href="get_residue_error_rate
.pl.html">get_residue_error_rate
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_residue_error_rate
.pl">get_residue_error_rate
.pl</A>
<pre>
<b>Argument  </b> : Takes a ref. for hash which have positions of residues of sequences.
<b>Author    </b> : A Biomatic
<b>Function  </b> : This is the final step in error rate getting.
             gets a ref. of a hash and calculates the absolute position diffs.
<b>Options   </b> : 'L' for limitting the error rate to 9 to make one digit output
$LIMIT becomes 'L' by L, l, -l, -L
<b>Returns   </b> : one ref. for an array of differences of input arrays. array context.
             ---Example input (a hash with sequences); The values are differences after
                                comparion with structural and sequential alignments.
             %diffs =('seq1', '117742433441...000',   <-- input (can be speparated by '' or ','.
                      'seq2', '12222...99999.8888',
                      'seq3', '66222...44444.8822',
                      'seq4', '12262...00666.772.');
             example output;
             seq3_seq4       '0,1,0,0,0,.,.,.,,.,0,,0,0,,0,0,,.,0,,0,0,.'
             seq1_seq2       '0,1,0,1,1,.,.,.,,.,2,,2,2,,2,2,,.,.,,2,2,1'
             seq1_seq3       '0,1,0,1,1,.,.,.,,.,1,,1,1,,0,.,,.,.,,1,1,1'
             seq1_seq4       '0,1,0,,1,1,.,.,.,,.,1,,1,1,0,.,.,,.,1,,2,2'
             seq2_seq3       '0,1,0,,0,0,,.,.,,.,0,,1,0,,0,0,,.,0,,0,0,0'
             seq2_seq4       '0,0,0,,1,0,,.,.,,.,0,,1,0,,0,0,,.,0,,0,0,.'
<b>Usage     </b> : %position_diffs =%{&get_residue_error_rate(\@seq_position1, \@seq_position2)};
<b>Used in   </b> : get_position_shift_rate, previously get_each_posi_diff_hash
<b>Version   </b> : 1.0
<b>Warning   </b> : split and join char is ',';
</pre><hr>

<H3><A href="tell_seq_length
.pl.html">tell_seq_length
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/tell_seq_length
.pl">tell_seq_length
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Class     </b> : Utility
<b>Function  </b> : tells the sequence sizes of given sequences
<b>Reference </b> : http://sonja.acad.cai.cam.ac.uk/bioperl.html
<b>Usage     </b> : %hash_out = %{&tell_seq_length(\%hash_in)};
<b>Version   </b> : 1.0
</pre><hr>

<H3><A href="handle_arguments
.pl.html">handle_arguments
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/handle_arguments
.pl">handle_arguments
.pl</A>
<pre>
<b>Argument  </b> : any type, any amount
<b>Author    </b> : A Biomatic
<b>Class     </b> : Perl::Utility::Arg_handling
<b>Example   </b> : 'handle_arguments(\@array, $string, \%hash, 8, 'any_string')
  ######################################################################(output example)###
  ## $char_opt  as ('A,B,C')            ## $num_opt   as ('1,-2,3')
  ## @char_opt  as (A, B, C)            ## @num_opt   as (1,-2, 3)
  ## @file      as (\file1, \file2,...) ## @dir       as (\dir1, \dir2,...)
  ## @array     as (\array1, \array2,,) ## @hash      as (\hash1, \hash2,,,,)
  ## @string    as ('any_str_no_file_no_dir_not_opt')
  #########################################################################################
<b>Function  </b> : Sorts input arguments going into subroutines and returns default
             arrays of references for various types (file, dir, hash, array,,,,)

<b>Keywords  </b> : handling arguments, parsing arguments,
<b>Tips      </b> : takes 0.02 u time with INDY
<b>Usage     </b> : Just put the whole box delimited by the two '###..' lines below
             to inside of your subroutines. It will call 'handle_arguments'
             subroutine and parse all the given input arguments.
             To use, claim the arguments, just use the variable in the box.
             For example, if you had passed 2 file names for files existing
             in your PWD(or if the string looks like this: xxxx.ext),
             you can claim them by $file[0], $file[1] in
             your subroutine.
   #""""""""""""""""""""""< handle_arguments{ head Ver 1.2 >""""""""""""""""""""""""""""""""
   my(@A ) = &handle_arguments( @_ ); my( $num_opt )=${$A[7]};my( $char_opt )=${$A[8]};
   my(@hash)  =@{$A[0]};my(@file)   =@{$A[4]};my(@dir   )  =@{$A[3]};my(@array)=@{$A[1]};
   my(@string)=@{$A[2]};my(@num_opt)=@{$A[5]};my(@char_opt)=@{$A[6]};my(@raw_string)=@{$A[9]};
   my($i, $j, $c, $d, $e, $f, $g, $h, $k, $l, $p, $q, $r, $s, $t, $u, $v, $w, $x,$y,$z);
   if($debug==1){ print "   \@hash has \"@hash\"\n   \@raw_string has \"@raw_string\"
   \@array has \"@array\"\n   \@char_opt has \"@char_opt\"\n   \@file has \"@file\"\n"; }
   #"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

<b>Used in   </b> : everywhere
<b>Version   </b> : 3.1
             set_debug_option  is added.
</pre><hr>

<H3><A href="set_debug_option
.pl.html">set_debug_option
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/set_debug_option
.pl">set_debug_option
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Class     </b> : Utility
<b>Example   </b> : set_debug_option #    <-- at prompt.
<b>Function  </b> : If you put '#' or  '##' at the prompt of any program which uses
             this sub you will get verbose printouts for the program if the program
             has a lot of comments.
<b>Options   </b> : #   for 1st level of verbose printouts
             ##  for even more verbose printouts
$debug  becomes 1 by '#'
$debug2 becomes 1 by '##'

<b>Reference </b> : http://sonja.acad.cai.cam.ac.uk/bioperl.html
<b>Returns   </b> : $debug
<b>Usage     </b> : &set_debug_option;
<b>Version   </b> : 1.7
             generalized debug var is added for more verbose printouts.
</pre><hr>

<H3><A href="parse_arguments
.pl.html">parse_arguments
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/parse_arguments
.pl">parse_arguments
.pl</A>
<pre>
<b>Argument  </b> : uses @ARGV
<b>Author    </b> : A Biomatic
<b>Function  </b> : Parse and assign any types of arguments on prompt in UNIX to
             the various variables inside of the running program.
             This is more visual than getopt and easier.
             just change the option table_example below for your own variable
             setttings. This program reads itself and parse the arguments
             according to the setting you made in this subroutine or
             option table in anywhere in the program.
<b>Options   </b> : '0'  to specify that there is no argument to sub, use
              &parse_arguments(0);
             parse_arguments itself does not have any specific option.
             '#' at prompt will make a var  $debug set to 1. This is to
              print out all the print lines to make debugging easier.
<b>Returns   </b> : Filenames in a reference of array
             and input files in an array (file1, file2)=@{&parse_arguments};
<b>Usage     </b> : &parse_arguments; or  (file1, file2)=@{&parse_arguments};
<b>Version   </b> : 1.2
<b>Warning   </b> : HASH and ARRAY mustn't be like = (1, 2,3) or (1,2 ,3)
</pre><hr>

<H3><A href="assign_options_to_variables
.pl.html">assign_options_to_variables
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/assign_options_to_variables
.pl">assign_options_to_variables
.pl</A>
<pre>
<b>Argument  </b> : None.
<b>Author    </b> : A Biomatic
<b>Example   </b> : When you want to set 'a' char to a variable called '$dummy' in
             the program, you put a head box commented line
             '#  $dummy    becomes  a  by  -a '
             Then, the parse_arguments and this sub routine will read the head
             box and assigns 'a' to $dummy IF you put an argument of '-a' in
             the prompt.
<b>Function  </b> : Assigns the values set in head box to the variables used in
             the programs according to the values given at prompt.
             This produces global values.
<b>Options   </b> : '#' at prompt will make a var  $debug set to 1. This is to
              print out all the print lines to make debugging easier.
<b>Package   </b> : Bio::Utils
<b>Returns   </b> : Some globaly used variables according to prompt options.
<b>Tips      </b> : Used with 'parse_arguments'
<b>Usage     </b> : &assign_options_to_variables(\$input_line);
<b>Version   </b> : 1.4
</pre><hr>

<H3><A href="remove_dup_in_array
.pl.html">remove_dup_in_array
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/remove_dup_in_array
.pl">remove_dup_in_array
.pl</A>
<pre>
<b>Argument  </b> : one or more refs for arrays.
<b>Example   </b> : (1,1,1,1,3,3,3,3,4,4,4,3,3,4,4);  --> (1,3,4);
<b>Function  </b> : removes duplicate entries in an array.
<b>Keywords  </b> : merge array elements, remove_repeting_elements, remove_array_elements
<b>Returns   </b> : one or more references.
<b>Usage     </b> : @out2 = @{&remove_dup_in_array(\@input1, \@input2,,,,)};
             @out1 = @{&remove_dup_in_array(\@input1 )};
<b>Version   </b> : 1.0
</pre><hr>

<H3><A href="default_help
.pl.html">default_help
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/default_help
.pl">default_help
.pl</A>
<pre>
<b>Example   </b> : &default_help2; &default_help2(\$arg_num_limit);   &default_help2( '3' );
             1 scalar digit for the minimum number of arg (optional),
             or its ref. If this defined, it will produce exit the program
             telling the minimum arguments.
<b>Function  </b> : Prints usage information and others when invoked. You need to have
             sections like this explanation box in your perl code. When invoked,
             default_help routine reads the running perl code (SELF READING) and
             displays what you have typed in this box.
             After one entry names like # Function :, the following lines without
             entry name (like this very line) are attached to the previous entry.
             In this example, to # Function : entry.
<b>Package   </b> : File_Util
<b>Returns   </b> : formated information
<b>Tips      </b> : This usually goes with  parse_arguments.pl (= easy_opt.pl)
<b>Usage     </b> : &default_help2;  usually with 'parse_arguments' sub.
<b>Version   </b> : 3
<b>Warning   </b> : this uses format and references
</pre><hr>

<H3><A href="read_head_box_help
.pl.html">read_head_box_help
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/read_head_box_help
.pl">read_head_box_help
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : Reads the header box(the one you see on top of sub routines of
             Jong's programs.
             There are two types of ending line one is Jong's #---------- ...
             the other is Astrid's  #*************** ...
<b>Package   </b> : File_Util
<b>Usage     </b> : %entries = %{&read_head_box(\$file_to_read )};
<b>Version   </b> : 1
</pre><hr>

<H3><A href="read_option_table
.pl.html">read_option_table
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/read_option_table
.pl">read_option_table
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Package   </b> : File_Util
</pre><hr>

<H3><A href="hash_stat_for_all
.pl.html">hash_stat_for_all
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/hash_stat_for_all
.pl">hash_stat_for_all
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Example   </b> : %in =(1, "13242442", 2, "92479270", 3, "2472937439");
             %in2=(1, "28472", 2, "23423240", 3, "123412342423439");

<b>Function  </b> : gets the min, max, av, sum for the whole values of ALL the
             hashes put in. (grand statistics)
<b>Returns   </b> : normal array of ($min, $max, $sum, $av)
             Example out
                -----------------------------------
                of the whole    |   0   9  110   6
<b>Usage     </b> : %out=%{&hash_average(\%in, \%in2,..)};
</pre><hr>

<H3><A href="get_posi_rates_hash_out_compact
.pl.html">get_posi_rates_hash_out_compact
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_posi_rates_hash_out_compact
.pl">get_posi_rates_hash_out_compact
.pl</A>
<pre>
<b>Argument  </b> : %{&get_posi_rates_hash_out(\%msfo_file, \%jpo_file)};
             Whatever the names, it takes one TRUE structral and one ALIGNED hash.
<b>Author    </b> : A Biomatic
<b>Function  </b> : This is to get position specific error rate for line display rather than
             actual final error rate for the alignment.
             Output >>  something like below but, without gaps, so final one is;
             seq1_seq2  1110...222...2222     seq1_seq2  11102222222
             seq2_seq3  1111....10...1111  -> seq2_seq3  1111101111
             seq1_seq3  1111....0000.0000     seq1_seq3  111100000000

<b>Returns   </b> : \%final_posi_diffs_compact;  Compare with  'get_posi_rates_hash_out_jp'
<b>Usage     </b> : %rate_hash = %{&get_posi_shift_hash(\%hash_msf, \%hash_jp)};
<b>Version   </b> : 1
<b>Warning   </b> : split and join char is ','; (space)
</pre><hr>

<H3><A href="get_posi_rates_hash_out_jp
.pl.html">get_posi_rates_hash_out_jp
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_posi_rates_hash_out_jp
.pl">get_posi_rates_hash_out_jp
.pl</A>
<pre>
<b>Argument  </b> : %{&get_posi_rates_hash_out_jp(\%msfo_file, \%jpo_file)};
             Whatever the names, it takes one TRUE structral and one ALIGNED hash.
<b>Author    </b> : A Biomatic
<b>Function  </b> : This is to get position specific error rate for line display rather than
             actual final error rate for the alignment. get_posi_rates_hash_out_jp
             results in jp template sequence, while get_posi_rates_hash_out_msf does
             in msf template sequence.
             Output >>
             seq1_seq2  1110...222...2222   <--- the alignment template is JPO's
             seq2_seq3  1111....10...1111        (ie structural)
             seq1_seq3  1111....0000.0000

<b>Returns   </b> : \%final_posi_diffs;
<b>Usage     </b> : %rate_hash = %{&get_posi_shift_hash(\%hash_msf, \%hash_jp)};
<b>Version   </b> : 1
<b>Warning   </b> : split and join char is ','; (space)
</pre><hr>

<H3><A href="get_posi_rates_hash_out
.pl.html">get_posi_rates_hash_out
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_posi_rates_hash_out
.pl">get_posi_rates_hash_out
.pl</A>
<pre>
<b>Argument  </b> : %{&get_posi_rates_hash_out(\%msfo_file, \%jpo_file)};
             Whatever the names, it takes one TRUE structral and one ALIGNED hash.
<b>Author    </b> : A Biomatic
<b>Function  </b> : This is to get position specific error rate for line display rather than
             actual final error rate for the alignment.
             Output >>
             seq1_seq2  1110...222...2222
             seq2_seq3  1111....10...1111
             seq1_seq3  1111....0000.0000

<b>Returns   </b> : \%final_posi_diffs;
<b>Usage     </b> : %rate_hash = %{&get_posi_shift_hash(\%hash_msf, \%hash_jp)};
<b>Version   </b> : 1
<b>Warning   </b> : split and join char is ','; (space)
</pre><hr>

<H3><A href="get_posi_rates_hash_out
.pl.html">get_posi_rates_hash_out
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_posi_rates_hash_out
.pl">get_posi_rates_hash_out
.pl</A>
<pre>
<b>Argument  </b> : %{&get_posi_rates_hash_out(\%msfo_file, \%jpo_file)};
             Whatever the names, it takes one TRUE structral and one ALIGNED hash.
             Output >>
             seq1_seq2  1110...222...2222
             seq2_seq3  1111....10...1111
             seq1_seq3  1111....0000.0000

<b>Author    </b> : A Biomatic
<b>Function  </b> : This is to get position specific error rate for line display rather than
             actual final error rate for the alignment.
<b>Returns   </b> : \%final_posi_diffs;
<b>Usage     </b> : %rate_hash = %{&get_posi_shift_hash(\%hash_msf, \%hash_jp)};
<b>Version   </b> : 1
<b>Warning   </b> : split and join char is ','; (space)
</pre><hr>

<H3><A href="compos_id_percent_array
.pl.html">compos_id_percent_array
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/compos_id_percent_array
.pl">compos_id_percent_array
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : produces amino acid composition identity of any given number of sequences.
<b>Usage     </b> : $percent = &compos_id_percent_array(@any_array_sequences);
             The way identity(composition) is derived is;
<b>Used in   </b> : get_windows_compos_and_seqid_rate_array,

</pre><hr>

<H3><A href="seq_id_percent_array
.pl.html">seq_id_percent_array
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/seq_id_percent_array
.pl">seq_id_percent_array
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : produces amino acid composition identity of any given number of sequences.
<b>Usage     </b> : $percent = &seq_id_percent_array(@any_array_sequences);
             The way identity(pairwise) is derived is;

<b>Warning   </b> : This can handle 'common gaps' in the sequences
</pre><hr>

<H3><A href="min_elem_array
.pl.html">min_elem_array
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/min_elem_array
.pl">min_elem_array
.pl</A>
<pre>
<b>Argument  </b> : numerical arrays
<b>Author    </b> : A Biomatic
<b>Function  </b> : gets the smallest element of any array of numbers.
<b>Returns   </b> : one or more ref. for scalar numbers.
<b>Usage     </b> : ($out1, $out2)=@{&min_elem_array(\@array1, \@array2)};
             ($out1)       =${&min_elem_array(\@array1)          };
</pre><hr>

<H3><A href="open_dssp_files
.pl.html">open_dssp_files
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/open_dssp_files
.pl">open_dssp_files
.pl</A>
<pre>
<b>Argument  </b> : files names like (6taa, 6taa.dssp) If you put just '6taa' without extension, it
             searches if there is a '6taa.dssp' in both PWD and $DSSP env. set directory.
             ---------- Example of dssp ---
             **** SECONDARY STRUCTURE DEFINITION BY THE PROGRAM DSSP, VERSION JUL
             REFERENCE W
             HEADER    RIBOSOME-INACTIVATING PROTEIN           01-JUL-94   1MRG
             COMPND    ALPHA-MOMORCHARIN COMPLEXED WITH ADENINE
             SOURCE    BITTER GOURD (CUCURBITACEAE MOMORDICA CHARANTIA) SEEDS
             AUTHOR    Q
             246  1  0  0  0 TOTAL NUMBER OF RESIDUES, NUMBER OF CHAINS, NUMBER OF SS-BRIDGES(TOTAL,INTRACHAIN,INTERCHAIN)                .
             112 95.0   ACCESSIBLE SURFACE OF PROTEIN (ANGSTROM**2)                                                                         .
             171 69.5   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(J)  , SAME NUMBER PER 100 RESIDUES                              .
             12   4.9   TOTAL NUMBER OF HYDROGEN BONDS IN     PARALLEL BRIDGES, SAME NUMBER PER 100 RESIDUES                              .
             36  14.6   TOTAL NUMBER OF HYDROGEN BONDS IN ANTIPARALLEL BRIDGES, SAME NUMBER PER 100 RESIDUES                              .
             1    0.4   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(I-5), SAME NUMBER PER 100 RESIDUES                              .
             1    0.4   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(I-4), SAME NUMBER PER 100 RESIDUES                              .
             74  30.1   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(I+4), SAME NUMBER PER 100 RESIDUES                              .
             5    2.0   TOTAL NUMBER OF HYDROGEN BONDS OF TYPE O(I)-->H-N(I+5), SAME NUMBER PER 100 RESIDUES                              .
             1    2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30     *** HISTOGRAMS OF ***           .
             0    0  0  0  1  1  0  2  0  0  1  0  0  1  0  0  0  0  0  2  0  0  0  0  0  0  0  0  0  0    RESIDUES PER ALPHA HELIX         .
             1    0  0  2  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0    PARALLEL BRIDGES PER LADDER      .
             2    0  1  2  0  1  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0    ANTIPARALLEL BRIDGES PER LADDER  .
             2    0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0    LADDERS PER SHEET                .
             #   RESIDUE AA STRUCTURE BP1 BP2  ACC   N-H-->O  O-->H-N  N-H-->O  O-->H-N    TCO  KAPPA ALPHA  PHI   PSI    X-CA   Y-CA   Z-CA
             1    1   D              0   0  132    0, 0.0   2,-0.3   0, 0.0  49,-0.2   0.000 360.0 360.0 360.0 153.4   44.0   96.9  -23.8
             2    2   V  E     -a   50   0A  10   47,-1.5  49,-2.8   2, 0.0   2,-0.3  -0.889 360.0-163.3-115.9 151.4   43.1  100.4  -22.5
             3    3   S  E     -a   51   0A  63   -2,-0.3   2,-0.3  47,-0.2  49,-0.2  -0.961  10.3-172.8-131.0 152.3   44.8  103.7  -23.4
             4    4   F  E     -a   52   0A   8   47,-2.2  49,-2.3  -2,-0.3   2,-0.4  -0.985   6.9-161.2-143.2 139.5   45.0  107.2  -22.0
             5    5   R  E     -a   53   0A 144   -2,-0.3   4,-0.2  47,-0.2  49,-0.2  -0.993   9.7-156.0-121.0 125.9   46.6  110.2  -23.6
             6    6   L  S    S+     0   0    1   47,-2.3   2,-0.5  -2,-0.4   3,-0.4   0.644  73.2  90.9 -73.3 -22.4   47.5  113.2  -21.4
             7    7   S  S    S+     0   0   81   47,-0.3   3,-0.1   1,-0.2  -2,-0.1  -0.695 106.0   5.2 -75.5 121.0   47.4  115.6  -24.4
             8    8   G  S    S+     0   0   72   -2,-0.5  -1,-0.2   1,-0.3   5,-0.1   0.269  97.6 147.8  90.2 -10.7   43.9  117.0  -24.7
             9    9   A        +     0   0   10   -3,-0.4  -1,-0.3  -4,-0.2  -3,-0.1  -0.256  16.8 166.8 -58.8 142.4   42.9  115.2  -21.5
             (\$inputfile1, \$inputfile2, .... )};
<b>Author    </b> : A Biomatic
<b>Function  </b> : open dssp files and put sequences in a hash(s)
              It can take options for specific secondary structure types. For example,
              if you put an option $H in the args of the sub with the value of 'H'
              open_dssp_files will only read secondary structure whenever it sees 'H'
              in xxx.dssp file ignoring any other sec. str. types.
              If you combine the options of 'H' and 'E', you can get only Helix and long
              beta strand sections defined as segments. This is handy to get sec. str. segments
              from any dssp files to compare with pdb files etc.
             With 'simplify' option, you can convert only all the 'T', 'G' and 'I' sec. to
              'H' and 'E'.
<b>Options   </b> : H, S, E, T, I, G, B, P, C, -help
 $H        =        'H' by   -H or -h or H or h  # to retrieve 4-helix (alpha helical)
 $S        becomes  'S' by   -S or -s or S or s  # to retrieve Extended strand, participates in B-ladder
 $E        becomes  'E' by   -E or -e or E or e  # to retrieve residue in isolated Beta-bridge
 $T        becomes  'T' by   -T or -t or T or t  # to retrieve H-bonded turn
 $I        becomes  'I' by   -I or -i or I or i  # to retrieve 5-helix (Pi helical) segment output
 $G        becomes  'G' by   -G or -g or G or g  # to retrieve 3-helix (3-10 helical)
 $B        becomes  'B' by   -B or -b or B or b  # to retrieve only B segment
 $simplify becomes   1  by   -p or P or -P, p
 $comm_col becomes  'c' by   -c or c or C or -C or common
 $HELP     becomes   1  by   -help   # for showing help

<b>Returns   </b> : (*out, *out2)  or (@out_array_of_refs)
<b>Usage     </b> : (*out, *out2) = @{&open_dssp_files(\$inputfile1, \$inputfile2, \$H, \$S,,,,)};
             (@out)        = @{&open_dssp_files(\$inputfile1, \$inputfile2, \$H, \$S,,,,)};
<b>Version   </b> : 2.8
$debug feature has been added to make it produce error messages with '#' option.
<b>Warning   </b> : 6taa.dssp  and 6taa are regarded as the same.
</pre><hr>

<H3><A href="get_common_column
.pl.html">get_common_column
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_common_column
.pl">get_common_column
.pl</A>
<pre>
<b>Argument  </b> : 2 or more ref for hash of identical keys and value length.
             One optional arg for replacing space char to the given one.
<b>Author    </b> : A Biomatic
<b>Class     </b> : get_common_column, get_common_column_in_seq, get common column in sequence
             for secondary structure only representation.
<b>Example   </b> : %out =%{&get_common_column(\%hash1, \%hash2, '-')};
             output> with 'E' option >>> "name1     --HHH--1232-"
   Following input will give;
  %hash1 = ('s1', '--EHH-CHHEE----EHH--HHEE----EHH--HHEE----EHH-CHHEE--');
  %hash2 = ('s2', '--EEH-CHHEE----EEH-CHHEE----EEH-CHHEE----EEH-CHHEE--');
  %hash3 = ('s3', '-KEEH-CHHEE-XX-EEH-CHHEE----EEH-CHHEE----EEH-CHHEE--');
  %hash4 = ('s4', '-TESH-CHEEE-XX-EEH-CHHEE----EEH-CHHEE----EEH-CHHEE--');

    s1_s2_s3_s4    --E-H-CH-EE----E-H--HHEE----E-H--HHEE----E-H-CHHEE--

<b>Function  </b> : (name1         --EHH--HHEE-- )
             (name2         --HHH--EEEE-- ) ==> result is;

             (name1_name2   -- HH--  EE-- )
             to get the identical chars in hash strings of sequences.

<b>Keywords  </b> : Overlap, superpose hash, overlay identical chars, superpose_seq_hash
             get_common_column, get_com_column
<b>Package   </b> : Array_Util
<b>Returns   </b> : one hash ref. of the combined key name (i.e., name1_name2). Combined by '_'
<b>Usage     </b> : %out =%{&get_common_column(\%hash1, \%hash2, '-')};
<b>Version   </b> : 1.5
<b>Warning   </b> : This gets more than 2 hashes. Not more than that!

</pre><hr>

<H3><A href="open_sst_files
.pl.html">open_sst_files
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/open_sst_files
.pl">open_sst_files
.pl</A>
<pre>
<b>Argument  </b> : a ref. for scaler of "jp file name"
<b>Author    </b> : A Biomatic
<b>Example   </b> : jp file  ==  seq1 ABDSF--DSFSDFS   <- true sequence
                          seq2 lkdf-jlsjlsjf

                 sst files == seq1.sst, seq2.sst

                 output hash == seq1 hHHHHHHHttEEEEEEEE
                                seq2 hHHHHHHHHHEEEEEEhh

<b>Function  </b> : gets the name of a sst file (6taa.sst) and/or its absolute
             dir path (aa).
             reads the sequence names in the jp file and looks up all
             the sst files in the same directory. Puts sst sequences
             in a hash with keys of sequence names.

<b>Returns   </b> : a ref. for a hash
<b>Usage     </b> : %out_sst_hash =%{&open_sst_files(\$jp_file_dir, \$file_name)};
<b>Warning   </b> : $jp_file_dir_and_name should be absolute dir and file name
             >> This gets JP file not SST file as input !!!!
</pre><hr>

<H3><A href="dir_search_single
.pl.html">dir_search_single
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/dir_search_single
.pl">dir_search_single
.pl</A>
<pre>
<b>Argument  </b> : One Ref. for a scalar.
<b>Author    </b> : A Biomatic
<b>Function  </b> : With given full path or single name for a dir. it returns
             the full path dir name. If it fails to find in pwd or given
             specified path, it tries to search PATH, HOME etc..
<b>Returns   </b> : one Ref. for an array.
<b>Usage     </b> : $output_best_possible_dir = ${&dir_search_single(\$input_name)};
</pre><hr>

<H3><A href="open_fas_files
.pl.html">open_fas_files
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/open_fas_files
.pl">open_fas_files
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : open fasta files and put sequences in a hash
             FASTA sequence file format is like this;

             > 1st-seq
             ABCDEFGHIJKLMOPABCDEFGHIJKLMOPABCDEFGHIJKLMOPABCDEFG
             > 2nd.sequ
             ABCDEFGHIJKLMOYYUIUUIUIYIKLMOPABCDEFGHIJKLMOPABCDEFG
             ABCDEFGHIJKLMOPABCDEFGHIJKLMOPPABCDEFGHIJKLMOP

<b>Usage     </b> : %anyhash = &read_fasta_files($any_sequence_file_fasta_form);
<b>Warning   </b> : well tested. It skips lines starting with blank, lines with '-' in them.
</pre><hr>

<H3><A href="convert_num_to_0_or_1_hash
.pl.html">convert_num_to_0_or_1_hash
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/convert_num_to_0_or_1_hash
.pl">convert_num_to_0_or_1_hash
.pl</A>
<pre>
<b>Argument  </b> : two references, one for hash one for scaler for threshold

<b>Author    </b> : A Biomatic
<b>Example   </b> : A hash =>  name1  10012924729874924792742749748374297
                        name2  10012924729874924792710012924729874
             A threshold => 4
             !! if numbers are smaller than 4, they become 1 (or true).
             Outputhash  =>  name1  11111011011111011111011011110101111
                        name2  11111011010001011001011010010101100

             ($ref1, $ref2)=&convert_num_to_0_or_1_hash(\%hash, \%hash, \$threshold);
             above is the example when with more than 2 input hashes.
<b>Function  </b> : changes all the numbers into 0 or 1 according to threshold given.
             convert_num_0_or_1_hash converts threshold and bigger nums. to
             '0' while convert_num_0_or_1_hash_opposite converts to '1'.
<b>Usage     </b> : with a variable for threshold ->

             %out = %{&convert_num_to_0_or_1_hash(\%input_hash, \$threshold, \%input_hash2..)};

<b>Warning   </b> : Threshold value is set to 0 as well as all values smaller than that.
</pre><hr>

<H3><A href="convert_num_0_or_1_hash_opposite
.pl.html">convert_num_0_or_1_hash_opposite
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/convert_num_0_or_1_hash_opposite
.pl">convert_num_0_or_1_hash_opposite
.pl</A>
<pre>
<b>Argument  </b> : two references, one for hash one for scaler for threshold

<b>Author    </b> : A Biomatic
<b>Example   </b> : A hash =>  name1  10012924729874924792742749748374297
                        name2  10012924729874924792710012924729874
             A threshold => 4
             !! if numbers are smaller than 4, they become 1 (or true).
             Outputhash  =>  name1  11111011011111011111011011110101111
                        name2  11111011010001011001011010010101100

             ($ref1, $ref2)=&convert_num_to_0_or_1_hash(\%hash, \%hash, \$threshold);
             above is the example when with more than 2 input hashes.
<b>Function  </b> : changes all the numbers into 0 or 1 according to threshold given.
             convert_num_0_or_1_hash converts threshold and bigger nums. to
             '0' while convert_num_0_or_1_hash_opposite converts to '1'.
<b>Usage     </b> : with a variable for threshold ->

               %out = %{&convert_num_0_or_1_hash_opposite(\%input_hash, \$threshold)};

<b>Warning   </b> : Threshold value is set to 0 as well as all values smaller than that.
</pre><hr>

<H3><A href="superpose_seq_hash
.pl.html">superpose_seq_hash
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/superpose_seq_hash
.pl">superpose_seq_hash
.pl</A>
<pre>
<b>Argument  </b> : 2 ref for hash of identical keys and value length.
<b>Author    </b> : A Biomatic
<b>Function  </b> : (name1 000000112324)+(name1  ABC..AD..EFD ) => (name1 000..01..324)
             uses the second hash a template for the first sequences. gap_char is
             '-' or '.'
<b>Returns   </b> : one hash ref.
<b>Usage     </b> : %out =%{&superpose_seq_hash(\%hash1, \%hash2)};
</pre><hr>

<H3><A href="open_fasta_files
.pl.html">open_fasta_files
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/open_fasta_files
.pl">open_fasta_files
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : open fasta files and put sequences in a hash
             FASTA sequence file format is like this;

             > 1st-seq
             ABCDEFGHIJKLMOPABCDEFGHIJKLMOPABCDEFGHIJKLMOPABCDEFG
             > 2nd.sequ
             ABCDEFGHIJKLMOYYUIUUIUIYIKLMOPABCDEFGHIJKLMOPABCDEFG
             ABCDEFGHIJKLMOPABCDEFGHIJKLMOPPABCDEFGHIJKLMOP

<b>Usage     </b> : %anyhash = &read_fasta_files($any_sequence_file_fasta_form);
<b>Warning   </b> : well tested. It skips lines starting with blank, lines with '-' in them.
</pre><hr>

<H3><A href="open_pdb_files
.pl.html">open_pdb_files
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/open_pdb_files
.pl">open_pdb_files
.pl</A>
<pre>
<b>Argument  </b> : one ref. for an inputfile (absolute
             >>> PDB example >>>
             SEQRES   1 A  284  MET ASP ALA ILE LYS LYS LYS MET GLN MET LEU LYS LEU  2TMA  51
             SEQRES   2 A  284  ASP LYS GLU ASN ALA LEU ASP ARG ALA GLU GLN ALA GLU  2TMA  52

<b>Author    </b> : A Biomatic
<b>Function  </b> : Convert a PDB structure file to FASTA format sequences.
<b>Returns   </b> : One ref. for a hash of sequences(DNA, RNA, PROTEIN (IN diff chains)
             If the two chains are identical, it rids of one of them and returns
             a name with out chain note-->  2tma, not 2tmaA and 2tmaB
<b>Usage     </b> : %out = %{&open_pdb_files(\$VAR)};
</pre><hr>

<H3><A href="open_msf_files
.pl.html">open_msf_files
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/open_msf_files
.pl">open_msf_files
.pl</A>
<pre>
<b>Argument  </b> : (\$inputfile1, \$inputfile2, .... )};
<b>Author    </b> : A Biomatic
<b>Function  </b> : open msf files and put sequences in a hash(s)
<b>Returns   </b> : (*out, *out2)  or (@out_array_of_refs)
<b>Usage     </b> : (*out, *out2) = @{&open_msf_files(\$inputfile1, \$inputfile2)};
             : (@out)        = @{&open_msf_files(\$inputfile1, \$inputfile2)};
             ---------- Example of MSF ---
             PileUp

             MSF:   85  Type: P    Check:  5063   ..

</pre><hr>

<H3><A href="hash_output_chk
.pl.html">hash_output_chk
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/hash_output_chk
.pl">hash_output_chk
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : checks hash output of any subroutine.
<b>Usage     </b> : &hash_output_chk(\%outing_hash);
</pre><hr>

<H3><A href="open_slx_files
             selex file (foo.slx) looks like this:

             #=SQ GLB_TUBTU  5.9393 - - 0..0::0 -
             #=SQ GGZLB      20.9706 - - 0..0::0 -

             HAHU        .........VLSPADKTNVKAAWGKVGA......HAGEYGAEALERMFLS
             HBA3_PANTR  .........VLSPADKTNVKAAWGKVGA......HAGZYGAEALERMFLS

.pl.html">open_slx_files
             selex file (foo.slx) looks like this:

             #=SQ GLB_TUBTU  5.9393 - - 0..0::0 -
             #=SQ GGZLB      20.9706 - - 0..0::0 -

             HAHU        .........VLSPADKTNVKAAWGKVGA......HAGEYGAEALERMFLS
             HBA3_PANTR  .........VLSPADKTNVKAAWGKVGA......HAGZYGAEALERMFLS

</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/open_slx_files
             selex file (foo.slx) looks like this:

             #=SQ GLB_TUBTU  5.9393 - - 0..0::0 -
             #=SQ GGZLB      20.9706 - - 0..0::0 -

             HAHU        .........VLSPADKTNVKAAWGKVGA......HAGEYGAEALERMFLS
             HBA3_PANTR  .........VLSPADKTNVKAAWGKVGA......HAGZYGAEALERMFLS

.pl">open_slx_files
             selex file (foo.slx) looks like this:

             #=SQ GLB_TUBTU  5.9393 - - 0..0::0 -
             #=SQ GGZLB      20.9706 - - 0..0::0 -

             HAHU        .........VLSPADKTNVKAAWGKVGA......HAGEYGAEALERMFLS
             HBA3_PANTR  .........VLSPADKTNVKAAWGKVGA......HAGZYGAEALERMFLS

.pl</A>
<pre>
<b>Argument  </b> : takes one ref. for a file.
<b>Author    </b> : A Biomatic
<b>Function  </b> : open slx files and put sequences in a hash
<b>Returns   </b> : a ref. of a hash
<b>Usage     </b> : %anyarray = &open_slx_files(\$any_sequence_file_msf_form);
<b>Warning   </b> : The MSF FORMAT SHOULD BE AT LEAST 30 residue long
</pre><hr>

<H3><A href="open_jp_files
.pl.html">open_jp_files
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/open_jp_files
.pl">open_jp_files
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : reads jp files and stores results in a hash.
<b>Returns   </b> : a reference of a hash for names and  their sequences.
<b>Usage     </b> : %out_hash=%{&open_jp_files(\$file_name)};
<b>Warning   </b> : All the spaces  '-' !!!
</pre><hr>

<H3><A href="open_aln_files
.pl.html">open_aln_files
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/open_aln_files
.pl">open_aln_files
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : reads jp files and stores results in a hash.
<b>Returns   </b> : a reference of a hash for names and  their sequences.
<b>Usage     </b> : %out_hash=%{&open_jp_files(\$file_name)};
</pre><hr>

<H3><A href="get_base_name
.pl.html">get_base_name
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_base_name
.pl">get_base_name
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : returns present working dir base
<b>Usage     </b> : $dir = ${&pwd_dir($any_absolute_path_dir)};
<b>Warning   </b> : well tested.
</pre><hr>

<H3><A href="open_sst_files_with_gap
.pl.html">open_sst_files_with_gap
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/open_sst_files_with_gap
.pl">open_sst_files_with_gap
.pl</A>
<pre>
<b>Argument  </b> : a ref. for scaler of "jp file name"
<b>Author    </b> : A Biomatic
<b>Example   </b> : jp file  ==  seq1 ABDSF--DSFSDFS   <- true sequence
                              seq2 T--kdf-GAGGGASF     (aligned)

                 sst files ==> 'seq1.sst', 'seq2.sst' (in the same dir)

             original sst format:  seq1 hHHHHHttEEEE  <-- No gaps!
                                  seq2 hHHHHHHEEhh
             After this sub ==>
             (final out hash =   (  seq1 hHHHH--HttEEEE  <-- inserted
                                  seq2 h--HHH-HHHEEEhh  )     gaps

<b>Function  </b> : gets the name of a file(jp file) with its absolute dir path
             reads the sequence names in the jp file and looks up all
             the sst files in the same directory. Puts sst sequences
             in a hash with keys of sequence names.

<b>Returns   </b> : a ref. for a hash
<b>Usage     </b> : %out_sst_hash =%{&open_sst_files_with_gap(\$jp_file_dir_and_name)};
<b>Warning   </b> : $jp_file_dir_and_name should be absolute dir and file name
             >> This gets JP file not SST file as input !!!!
</pre><hr>

<H3><A href="put_gaps_in_hash
.pl.html">put_gaps_in_hash
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/put_gaps_in_hash
.pl">put_gaps_in_hash
.pl</A>
<pre>
<b>Argument  </b> : 2 hash references.
<b>Author    </b> : A Biomatic
<b>Returns   </b> : one hash reference.
<b>Usage     </b> : %out=%{&put_gaps_in_hash(\%hash_with_gap, \%hash_sans_gap)};

             %hash1=('1ctx',  '111111111111111',      <-- hash input without gaps
             '2ctx',  '2222222222222222',
             '3ctx',  '3333333333');

             %hash2=('1ctx',  'AAA--AAAAAAAAAAAA-',   <-- hash input with template gaps
             '2ctx',  'BBBBBBBBBBBB-BBBB',
             '3ctx',  'CCCCCC----CCCC');

             >> resulting out hash;

             %hash3=('1ctx',     '111--111111111111-',
             '2ctx',     '222222222222-2222',
             '3ctx',     '333333----3333 );

<b>Warning   </b> : The keys for hashes should be the same and the two sequences
             should be identical.
</pre><hr>

<H3><A href="hash_common_by_keys
.pl.html">hash_common_by_keys
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/hash_common_by_keys
.pl">hash_common_by_keys
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Returns   </b> : the VALUES OF THE FIRST HASH which occur in later hashes
             are returned
<b>Usage     </b> : %hash1_value = %{&hash_common_by_keys(\%hash1, \%hash2,...)};
</pre><hr>

<H3><A href="get_base_names
.pl.html">get_base_names
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_base_names
.pl">get_base_names
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Example   </b> : $base => 'test'  with 'test.txt' or '/home/dir/of/mine/text.txt'
<b>Function  </b> : produces the file base name(eg, "evalign"  out of "evalign.pl" ).
<b>Keywords  </b> : get_base_name{, base_name, file_base_name ,  get_file_base_name
<b>Package   </b> : Jong_Util
<b>Usage     </b> : $base =${&get_base_names(\$file_name)};
             :   or @bases = &get_base_names(\@files);  # <-- uses `pwd` for abs directory
<b>Version   </b> : 1.1
</pre><hr>

<H3><A href="get_posi_sans_gaps
.pl.html">get_posi_sans_gaps
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_posi_sans_gaps
.pl">get_posi_sans_gaps
.pl</A>
<pre>
<b>Argument  </b> : one scalar variable input of sequence string.
<b>Author    </b> : A Biomatic
<b>Returns   </b> : the positions of residues after removing gaps(but keeps pos).
               used for analysis of shifted positions of seq. comparison.
<b>Usage     </b> : @seq_position1 = &get_posi_sans_gaps($string1);
</pre><hr>

<H3><A href="get_posi_diff
.pl.html">get_posi_diff
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_posi_diff
.pl">get_posi_diff
.pl</A>
<pre>
<b>Argument  </b> : Takes two ref. for arrays which have positions of residues.
<b>Author    </b> : A Biomatic
<b>Example   </b> : @compacted_posi_dif =(1 ,2, 1, 1, '.' ,2,  1,  1, '.');
             @compacted_posi_dif2=(4 ,2, 1, 1, ,2,  1, '.' ,3,  1);
             output ==> ( 3 0 0 0 . 1 . 2 .)   (it ignores positions which have non digits.
             output ==> (-3 0 0 0 . 1 .-2 .) when abs is not used.
<b>Returns   </b> : one ref. for an @array of differences of input arrays. array context.
<b>Usage     </b> : @position_diffs =&get_posi_diff(\@seq_position1,\@seq_position2);
<b>Used in   </b> : evalign.pl, get_position_shift_rate
<b>Version   </b> : 1.4
</pre><hr>

<H3><A href="remov_com_column
.pl.html">remov_com_column
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/remov_com_column
.pl">remov_com_column
.pl</A>
<pre>
<b>Argument  </b> : accepts reference for hash(es) and array(s).
<b>Author    </b> : A Biomatic
<b>Function  </b> : removes common gap column in seq.
<b>Returns   </b> : a ref. of  hash(es) and array(s).

             name1   ABCDE
             name2   ABCDEE
             name3

             (ABC
             from above the two column of dot will be removed
             To remove absurd gaps in multiple sequence alignment
<b>Usage     </b> : %new_string = %{&remov_com_column(\%hashinput)};
             @out=@{&remov_com_column(\@array3)};
</pre><hr>

<H3><A href="put_position_back_to_str_seq
.pl.html">put_position_back_to_str_seq
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/put_position_back_to_str_seq
.pl">put_position_back_to_str_seq
.pl</A>
<pre>
<b>Argument  </b> : takes two refs for arrays (one for char the other for digits
<b>Author    </b> : A Biomatic
<b>Example   </b> : @string_from_struct=('X', 'T', 'A' ,'B' , '.' ,'F',  'G', '.' , 'O' ,'P', '.');
             @compacted_posi_dif=(1 ,2, 1, 1, ,2, 1, 1, 1);
<b>Returns   </b> : a ref. for an array
<b>Usage     </b> : @result =@{&put_position_back_to_str_seq(\@string_from_struct, \@compacted_posi_dif)};
<b>Version   </b> : 1
</pre><hr>

<H3><A href="find_seq_files
.pl.html">find_seq_files
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/find_seq_files
.pl">find_seq_files
.pl</A>
<pre>
<b>Argument  </b> : (\$input_file_name) while $input_file_name can be  'xxx.xxx', or '/xxx/xxx/xxx/xxy.yyy'
             or just directory name like 'aat' for  /nfs/ind4/ccpe1/people/A Biomatic /jpo/align/aat
             then, it tries to find a file with stored seq file extensions like msf, jp, pir etc
             to make aat.msf, aat.jp, aat.pir ... and searches for these files.
<b>Author    </b> : A Biomatic
<b>Example   </b> : $found_file=${&find_seq_files(\$input_file_name)};
<b>Function  </b> : seeks given test file in pwd, specified dir, default path etc.
             If not found yet, it looks at all the subdirectories of path and pwd.
             PATH environment dirs, then returns full path file name.
<b>Returns   </b> : return( \$final );
<b>Usage     </b> : $found_file = ${&find_seq_files(\$input_file_name)};
</pre><hr>

<H3><A href="read_any_seq_files
.pl.html">read_any_seq_files
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/read_any_seq_files
.pl">read_any_seq_files
.pl</A>
<pre>
<b>Argument  </b> : one of more ref. for scalar.
<b>Author    </b> : A Biomatic
<b>Example   </b> : (*out1,  *out2) =&read_any_seq_files(\$input1, \$input2);
             : (@out_ref_array)=@{&read_any_seq_files(\$input1, \$input2)};
             : (%one_hash_out) =%{&read_any_seq_files(\$input1)};
<b>Function  </b> : Tries to find given input regardless it is full pathname, with or
             without extension. If not in pwd, it searches the dirs exhaustively.
<b>Returns   </b> : 1 ref. for a HASH of sequence ONLY if there was one hash input
             1 array (not REF.) of references for multiple hashes.
<b>Usage     </b> : %out_seq=%{&read_any_seq_file(\$input_file_name)};
<b>Version   </b> : 1
</pre><hr>

<H3><A href="dir_name
.pl.html">dir_name
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/dir_name
.pl">dir_name
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : returns present working dir name
<b>Usage     </b> : $dir = &pwd_dir($any_absolute_path_dir);
<b>Warning   </b> : well tested.
</pre><hr>

<H3><A href="get_base_name
.pl.html">get_base_name
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_base_name
.pl">get_base_name
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Example   </b> : $base => test  with 'test.txt' or '/home/dir/of/mine/text.txt'
<b>Function  </b> : produces the file base name.
<b>Usage     </b> : $base =${&get_base_name(\$absolute_dir)};
             or $base =${&get_base_name};  # <-- uses `pwd` for abs directory
</pre><hr>

<H3><A href="dir_path
.pl.html">dir_path
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/dir_path
.pl">dir_path
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Function  </b> : returns directory path (= pwd ), eg.  /nfs/ind4/ccpe1/people/A Biomatic
<b>Usage     </b> : $any_path = &dir_path($any_directory); or &dir_path('.') for pwd.
</pre><hr>

<H3><A href="get_each_posi_diff_hash
.pl.html">get_each_posi_diff_hash
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/get_each_posi_diff_hash
.pl">get_each_posi_diff_hash
.pl</A>
<pre>
<b>Argument  </b> : Takes a ref. for hash which have positions of residues of sequences.
<b>Author    </b> : A Biomatic
<b>Function  </b> : gets a ref. of a hash and calculates the position diffs.
<b>Returns   </b> : one ref. for an array of differences of input arrays. array context.
             ---Example input (a hash with sequences); The values are differences after
                                comparion with structural and sequential alignments.
             %diffs =('seq1', '117742433441...000',   <-- input (can be speparated by '' or ','.
               'seq2', '12222...99999.8888',
             'seq3', '66222...44444.8822',
             'seq4', '12262...00666.772.');
             example output;
             seq3_seq4       '0,1,0,0,0,.,.,.,,.,0,,0,0,,0,0,,.,0,,0,0,.'
             seq1_seq2       '0,1,0,1,1,.,.,.,,.,2,,2,2,,2,2,,.,.,,2,2,1'
             seq1_seq3       '0,1,0,1,1,.,.,.,,.,1,,1,1,,0,.,,.,.,,1,1,1'
             seq1_seq4       '0,1,0,,1,1,.,.,.,,.,1,,1,1,0,.,.,,.,1,,2,2'
             seq2_seq3       '0,1,0,,0,0,,.,.,,.,0,,1,0,,0,0,,.,0,,0,0,0'
             seq2_seq4       '0,0,0,,1,0,,.,.,,.,0,,1,0,,0,0,,.,0,,0,0,.'
<b>Usage     </b> : %position_diffs =%{&get_each_posi_diff_hash(\@seq_position1, \@seq_position2)};
<b>Warning   </b> : split and join char is ',';
</pre><hr>

<H3><A href="sum_hash
.pl.html">sum_hash
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/sum_hash
.pl">sum_hash
.pl</A>
<pre>
<b>Argument  </b> : ref. of an array of numbers.
<b>Author    </b> : A Biomatic
<b>Example   </b> : %hashinput= ( name1, '12..3e',
                            name2, '...234');
             $result = 1+2+3+2+3+4 = 15 (from above example)
<b>Function  </b> : sum of all the  numbers in valuse of a hash
<b>Returns   </b> : a ref. of a scaler.
<b>Usage     </b> : $out = &sum_array(%anyhash);
<b>Warning   </b> : It only gets digits in the input strings and sums them up.
</pre><hr>

<H3><A href="sum_array
.pl.html">sum_array
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/sum_array
.pl">sum_array
.pl</A>
<pre>
<b>Argument  </b> : ref. of an array of numbers.
<b>Author    </b> : A Biomatic
<b>Function  </b> : sum of all the  elements of an array .
<b>Returns   </b> : a ref. of a scaler.
<b>Usage     </b> : $out =  ${&sum_array(\@anyarray)};
</pre><hr>

<H3><A href="print_seq_in_block
.pl.html">print_seq_in_block
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/print_seq_in_block
.pl">print_seq_in_block
.pl</A>
<pre>
<b>Argument  </b> : many refs  for hash (one for bottm, one for top, etc,top hash is usually
               to denote certain caculations or results of the bottom one
<b>Author    </b> : A Biomatic
<b>Example   </b> : If there are 3 hashes; (in the order of \%hash3, \%hash2, \%hash1)
             >> 1st Hash        >> 2nd Hash         >> 3rd Hash          Output >>>
             Name1  THIS-IS-    Name123  eHHHHHHH   Name123  12222223    Name123  12222223
                                                              Name123  eHHHHHHH
             options should be single chars                              Name1    THIS-IS-
<b>Function  </b> : gets many refs  for one scalar  or hashes and prints
               the contents in lines of \$block_leng(the only scalar ref. given) char.
<b>Options   </b> : 'o' or 'O' => ordered hash print, 'n' or'N' => no space between blocks.
             's' or 'S' => printout sorted by seq names.(all options can be like \$sort
             while $sort has 's' as value. naked number like 100 will be the
             block_length. 'i' or 'I' => interlaced print.(this requires
             identical names in hashes)
             Example of ( no option, DEFAULT )        # Example of ( 'i' or 'I' option, INTERLACE )
             6taa           ------ATPADWRSQSIY      #   6taa           ------ATPADWRSQSIY
             2aaa           ------LSAASWRTQSIY      #   6taa           ------CCHHHHCCCCEE
             1cdg           APDTSVSNKQNFSTDVIY      #   6taa           ------563640130000
                                           #
             6taa           ------CCHHHHCCCCEE      #   2aaa           ------LSAASWRTQSIY
             2aaa           ------CCHHHHCCCCEE      #   2aaa           ------CCHHHHCCCCEE
             1cdg           CCCCCCCCCCCCCCCCEE      #   2aaa           ------271760131000
                                           #
             6taa           ------563640130000      #   1cdg           APDTSVSNKQNFSTDVIY
             2aaa           ------271760131000      #   1cdg           CCCCCCCCCCCCCCCCEE
             1cdg           675232723600000000      #   1cdg           675232723600000000
                                           #
             Example of ('s' or 'S' option, SORT )    # Example of ('o' or 'O' option, ORDERED by input hashes
             1cdg           APDTSVSNKQNFSTDVIY      #   6taa           ------ATPADWRSQSIY
             2aaa           ------LSAASWRTQSIY      #   2aaa           ------LSAASWRTQSIY
             6taa           ------ATPADWRSQSIY      #   1cdg           APDTSVSNKQNFSTDVIY
                                           #
             1cdg           CCCCCCCCCCCCCCCCEE      #   6taa           ------CCHHHHCCCCEE
             2aaa           ------CCHHHHCCCCEE      #   2aaa           ------CCHHHHCCCCEE
             6taa           ------CCHHHHCCCCEE      #   1cdg           CCCCCCCCCCCCCCCCEE
                                           #
             1cdg           675232723600000000      #   6taa           ------563640130000
             2aaa           ------271760131000      #   2aaa           ------271760131000
             6taa           ------563640130000      #   1cdg           675232723600000000
<b>Usage     </b> : &print_seq_in_block (\$block_leng, 'i',\%h1, 'sort', \%h2, \%hash3,,,);
</pre><hr>

<H3><A href="cls
.pl.html">cls
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/cls
.pl">cls
.pl</A>
<pre>
<b>Author    </b> : A Biomatic
<b>Example   </b> : &cls;
<b>Function  </b> : clears screen
<b>Usage     </b> : &cls;
<b>Version   </b> : 1.0
</pre><hr>

<H3><A href="read_dir_names_only
.pl.html">read_dir_names_only
</A></H3>Download <A href="ftp://ftp.mrc-lmb.cam.ac.uk/pub/genomes/jong/Perl/read_dir_names_only
.pl">read_dir_names_only
.pl</A>
<pre>
<b>Argument  </b> : takes one or more scaler references. ('.', \$path, $path, ... )
<b>Author    </b> : A Biomatic
<b>Function  </b> : read any dir names and and then put in array.
<b>Returns   </b> : one ref. of array.
<b>Usage     </b> : @all_dirs_list = @{&read_dir_names_only(\$absolute_path_dir_name, ....)};
<b>Version   </b> : 3.1
<b>Warning   </b> : This does not report '.', '..'
             Only file names are reported. Compare with &read_any_dir
</pre><hr>

</html>
